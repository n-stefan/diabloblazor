@page "/"

@inject AppState AppState
@inject Interop Interop
@inject Worker Worker
@inject ExceptionHandler ExceptionHandler
@*@inject HttpClient HttpClient
    @inject IndexedDbManager IndexedDbManager*@

<div id="main" class="App @(AppState.Started ? "started" : "") @(AppState.DropZone == DropZone.Show ? "dropping" : "")" @ondragenter="OnDragEnter" @ondragleave="OnDragLeave">
    <div class="Body">
        <div class="inner">
            @if (!AppState.Error)
            {
                <canvas id="theCanvas" width="640" height="480" tabindex="1"
                        @onmousemove="OnMouseMove" @onmousedown="OnMouseDown" @onmouseup="OnMouseUp" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" />
            }
        </div>
    </div>
    <div class="BodyV">
        @if (AppState.ShowSaves)
        {
            <div class="start">
                <ul class="saveList">
                    @if (AppState.Saves.Count == 0)
                    {
                        @:There are no saves.
                    }
                    else
                    {
                        @:Saves:
                        foreach (var save in AppState.Saves)
                        {
                            <li @key="save.Name">
                                <div class="saveName">@save.ShortName</div><span class="info">@save.GameType</span>
                                <i class="btnDownload fa fa-download" @onclick="() => DownloadSave(save.Name)"></i>
                                <i class="btnRemove fa fa-times" @onclick="() => RemoveSave(save.Name, save.ShortName)"></i>
                            </li>
                        }
                    }
                </ul>
                <a @ref="downloadLink" class="hidden"></a>
                <label for="saveInput" class="startButton">Upload Save</label>
                <input accept=".sv" type="file" id="saveInput" class="hidden" @onchange="ParseSaveFile" />
                <div class="startButton" @onclick="GoBack">Back</div>
            </div>
        }
        else if (AppState.Loading && !AppState.Started)
        {
            <div class="loading">
                @(AppState.Progress.Message ?? "Loading...")
                @if (AppState.Progress.Total != 0)
                {
                    <span class="progressBar"><span><span style="width: @ProgressBarWidth%" /></span></span>
                }
            </div>
        }
        else if (!AppState.Started)
        {
            <div class="start">
                <p>
                    Based on the excellent <a href="https://github.com/d07RiV/diabloweb">DiabloWeb</a> which, in turn, is based on the likewise excellent <a href="https://github.com/diasurgical/devilution">Devilution</a>.
                    The project page with information and links can be found over here: <a href="https://github.com/n-stefan/diabloblazor">https://github.com/n-stefan/diabloblazor</a>.
                </p>
                <p>
                    If you own the original game, you can drop the original DIABDAT.MPQ onto this page or click the button below to start playing.
                    The game can be purchased from <a href="https://www.gog.com/game/diablo">GoG</a>.
                    @*<span class="link" @onclick="CompressMPQ">Click here to compress the MPQ, greatly reducing its size.</span>*@
                </p>
                @if (!AppState.HasSpawn)
                {
                    <p>
                        Or you can play the shareware version for free (25MB download).
                    </p>
                }
                <label for="mpqInput" class="startButton">Browse for DIABDAT.MPQ</label>
                <div class="startButton" @onclick="() => Start()">Play Shareware</div>
                @if (AppState.Saves.Count > 0)
                {
                    <div class="startButton" @onclick="ShowSaves">Manage Saves</div>
                }
            </div>
        }
        <input accept=".mpq" type="file" id="mpqInput" class="hidden" @onchange="ParseMpqFile" />
    </div>
</div>

@code
{
    //TODO: Modularize

    private const string retailFilename = "diabdat.mpq";
    private const string spawnFilename = "spawn.mpq";
    private static readonly int[] spawnFilesizes = { 50_274_091, 25_830_791 };
    private string saveName;
    private ClientRect canvasRect;
    private bool offscreen;
    private GameType gameType;
    private Timer timer;
    private ElementReference downloadLink;

    //private Dictionary<string, byte[]> fileSystem;

    public bool Offscreen { get => offscreen; }
    public GameType GameType { get => gameType; }
    public Timer Timer { set => timer = value; }

    protected override async Task OnInitializedAsync()
    {
        await InitFileSystem();

        if (await Interop.HasFile(spawnFilename, spawnFilesizes))
            AppState.HasSpawn = true;

        await InitSaves();

        canvasRect = await Interop.GetCanvasRect();

        ExceptionHandler.OnException += (_, message) => Interop.Alert($"An error has occured: {message}");

        await Interop.AddEventListeners();

        await Interop.StoreDotNetReference(DotNetObjectReference.Create<Main>(this));
    }

    //private bool PointerLocked()
    //{
    //    return document.pointerLockElement === this.canvas || document.mozPointerLockElement === this.canvas;
    //}

    [JSInvokable]
    public async Task SetCursorPos(double x, double y)
    {
        //const rect = this.canvas.getBoundingClientRect();
        //this.cursorPos = {
        //    x: rect.left + (rect.right - rect.left) * x / 640,
        //    y: rect.top + (rect.bottom - rect.top) * y / 480,
        //};

        await Interop.DApiMouse(0, 0, 0, x, y);
    }

    private (double x, double y) MousePos(MouseEventArgs e)
    {
        double tx = 0, ty = 0;
        //if (PointerLocked())
        //{
        tx = Max(canvasRect.Left, Min(canvasRect.Right, tx + e.ClientX));
        ty = Max(canvasRect.Top, Min(canvasRect.Bottom, ty + e.ClientY));
        //}
        //else
        //{
        //    tx = e.ClientX;
        //    ty = e.ClientY;
        //}
        return (
            x: Max(0, Min(Round((tx - canvasRect.Left) / (canvasRect.Right - canvasRect.Left) * 640), 639)),
            y: Max(0, Min(Round((ty - canvasRect.Top) / (canvasRect.Bottom - canvasRect.Top) * 480), 479))
        );
    }

    private int MouseButton(MouseEventArgs e) =>
        e.Button switch
        {
            0 => 1,
            1 => 4,
            2 => 2,
            3 => 5,
            4 => 6,
            _ => 1
        };

    private int EventModifiers(EventArgs e)
    {
        //A common base class with at least ShiftKey, CtrlKey and AltKey would be nice
        if (e is MouseEventArgs me)
            return ((me.ShiftKey /*|| this.touchMods[TOUCH_SHIFT]*/) ? 1 : 0) + (me.CtrlKey ? 2 : 0) + (me.AltKey ? 4 : 0) /*+ (e.touches ? 8 : 0)*/;
        else if (e is KeyboardEventArgs ke)
            return ((ke.ShiftKey /*|| this.touchMods[TOUCH_SHIFT]*/) ? 1 : 0) + (ke.CtrlKey ? 2 : 0) + (ke.AltKey ? 4 : 0) /*+ (e.touches ? 8 : 0)*/;
        else
            throw new Exception($"Parameter '{nameof(e)}' must be of type MouseEventArgs or KeyboardEventArgs!");
    }

    private int GetKeyCode(KeyboardEventArgs e) =>
        e.Code switch
        {
            string s when s.StartsWith("F") => int.Parse(s.Substring(1)) + 111,
            string s when s.StartsWith("Key") => (int)s[s.Length - 1] - 32,
            string s when s.StartsWith("Digit") => (int)s[s.Length - 1] + 48,
            string s when s.StartsWith("Shift") => 16,
            "Backspace" => 8,
            "Tab" => 9,
            "Enter" => 13,
            "Escape" => 27,
            "Space" => 32,
            "ArrowLeft" => 37,
            "ArrowUp" => 38,
            "ArrowRight" => 39,
            "ArrowDown" => 40,
            "Equal" => 187,
            "Minus" => 189,
            _ => (int)e.Code[0]
        };

    private async Task OnMouseMove(MouseEventArgs e)
    {
        var (x, y) = MousePos(e);
        await Interop.DApiMouse(0, 0, EventModifiers(e), x, y);
    }

    private async Task OnMouseDown(MouseEventArgs e)
    {
        var (x, y) = MousePos(e);

        //if (window.screen && window.innerHeight === window.screen.height) {
        //  // we're in fullscreen, let's get pointer lock!
        //  if (!this.pointerLocked()) {
        //    this.canvas.requestPointerLock();
        //  }
        //}

        await Interop.DApiMouse(1, MouseButton(e), EventModifiers(e), x, y);
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        var (x, y) = MousePos(e);
        await Interop.DApiMouse(2, MouseButton(e), EventModifiers(e), x, y);
    }

    //TODO: Check Backspace, preventDefault
    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        var keyCode = GetKeyCode(e);

        await Interop.DApiKey(0, EventModifiers(e), keyCode);

        if (keyCode >= 32 && e.Key.Length == 1)
            await Interop.DApiChar((int)e.Key[0]);
        else if (keyCode == 8 || keyCode == 13)
            await Interop.DApiChar(keyCode);

        //if (e.keyCode === 8 || e.keyCode === 9 || (e.keyCode >= 112 && e.keyCode <= 119))
        //  e.preventDefault();
    }

    private async Task OnKeyUp(KeyboardEventArgs e) =>
        await Interop.DApiKey(1, EventModifiers(e), GetKeyCode(e));

    private void OnDragEnter(DragEventArgs e) =>
        AppState.DropZone = DropZone.Show;

    //TODO: Check
    private void OnDragLeave(DragEventArgs e) =>
        AppState.DropZone = DropZone.Hide;

    [JSInvokable]
    public void OnResize(ClientRect rect) =>
        canvasRect = rect;

    private async Task InitFileSystem()
    {
        //var store = await IndexedDbManager.GetRecords<IndexedDbFile>("kv");
        //return store.ToDictionary(x => x.Name, x => x.Data);

        await Interop.InitIndexedDb();
    }

    private async Task InitSaves()
    {
        var filenames = await Interop.GetFilenames();
        var saveNames = filenames.Where(x => x.EndsWith(".sv")).ToList();
        saveNames.ForEach(x => AppState.Saves.Add(new SaveGame(x)));
    }

    private void CompressMPQ() =>
        AppState.Compress = true;

    private string ExtractFilename(string path)
    {
        //Path.GetFileName doesn't seem to do the trick
        var index = path.LastIndexOf(@"\");
        return (index != -1) ? path.Substring(index + 1) : path;
    }

    private async Task ParseSaveFile(ChangeEventArgs e)
    {
        var name = ExtractFilename(e.Value.ToString()).ToLower();
        await Upload(name);
    }

    private async Task Upload(string name)
    {
        if (name != null && !name.EndsWith(".sv"))
        {
            Interop.Alert("Please select an SV file.");
            return;
        }

        if (await Interop.IndexedDbHasFile(name))
        {
            Interop.Alert($"Save '{name}' already exists.");
            return;
        }

        await Interop.UploadFile();
        AppState.Saves.Add(new SaveGame(name));
    }

    private async Task ParseMpqFile(ChangeEventArgs e)
    {
        var name = ExtractFilename(e.Value.ToString()).ToLower();
        await Start(name);
    }

    [JSInvokable]
    public async Task Start(string name = null, bool isDrop = false)
    {
        //if (this.compressMpq)
        //    this.compressMpq.start(file);

        if (name != null && !name.EndsWith(".mpq"))
        {
            Interop.Alert("Please select an MPQ file. If you downloaded the installer from GoG, you will need to install it on PC and use the MPQ file from the installation folder.");
            AppState.DropZone = DropZone.None;
            StateHasChanged();
            return;
        }

        gameType = (name != null && name == retailFilename) ? GameType.Retail : GameType.Shareware;

        AppState.DropZone = isDrop ? DropZone.Hide : DropZone.None;
        AppState.Loading = true;

        await LoadGame();

        //document.addEventListener('contextmenu', this.onMenu, true);

        //document.addEventListener('touchstart', this.onTouchStart, { passive: false, capture: true});
        //document.addEventListener('touchmove', this.onTouchMove, { passive: false, capture: true});
        //document.addEventListener('touchend', this.onTouchEnd, { passive: false, capture: true});

        //document.addEventListener('pointerlockchange', this.onPointerLockChange);

        AppState.DropZone = DropZone.None;
        AppState.Started = true;

        StateHasChanged();
    }

    private void GoBack() =>
        AppState.ShowSaves = false;

    private async Task DownloadSave(string name)
    {
        var data = await Interop.ReadIndexedDbAsBase64String(name);
        await Interop.ClickDownloadLink(downloadLink, name, $"data:application/octet-stream;base64,{data}");
        //await Interop.DownloadFile(name);
    }

    private async Task RemoveSave(string name, string shortName)
    {
        if (Interop.Confirm($"Are you sure you want to delete {shortName}?"))
        {
            await Interop.RemoveFile(name);
            var saveToRemove = AppState.Saves.FirstOrDefault(x => x.Name == name);
            AppState.Saves.Remove(saveToRemove);
        }
    }

    private void ShowSaves() =>
        AppState.ShowSaves = !AppState.ShowSaves;

    private async Task LoadGame()
    {
        await Interop.InitGraphics(offscreen);
        await Interop.InitSound();
        await DoLoadGame();
    }

    private async Task DoLoadGame()
    {
        if (gameType == GameType.Retail)
            await LoadRetail();
        else
            await LoadSpawn();

        //let packetQueue = [];
        //const webrtc = webrtc_open(data =>
        //{
        //    packetQueue.push(data);
        //});

        await Worker.InitGame(this);
    }

    private async Task LoadRetail()
    {
        if (!await Interop.HasFile(retailFilename))
            if (AppState.DropZone == DropZone.Hide)
                await Interop.SetDropFile();
            else
                await Interop.SetInputFile();
    }

    private async Task LoadSpawn()
    {
        var filesize = await Interop.GetFilesize(spawnFilename);
        if (filesize != 0 && !spawnFilesizes.Contains(filesize))
        {
            //await IndexedDbManager.DeleteRecord<string>("kv", spawnFilename);

            await Interop.RemoveFile(spawnFilename);
            filesize = 0;
        }
        if (filesize == 0)
        {
            //HttpClient.DefaultRequestHeaders.Add("Cache-Control", "max-age=31536000");
            //TODO: URL from config
            var url = $"http://localhost:53287/{spawnFilename}";
            //var spawn = await HttpClient.GetByteArrayAsync(url);

            //fileSystem[spawnFilename] = spawn;

            //var indexedDBFile = new IndexedDbFile { Name = spawnFilename, Data = spawn };
            //var storeRecord = new StoreRecord<IndexedDbFile> { Storename = "kv", Data = indexedDBFile };
            //await IndexedDbManager.UpdateRecord<IndexedDbFile>(storeRecord);

            //TODO: When serialization is fast enough
            //await Interop.UpdateIndexedDb(spawnFilename, spawn);

            filesize = await Interop.DownloadAndUpdateIndexedDb(url, spawnFilename, spawnFilesizes);

            if (!spawnFilesizes.Contains(filesize))
                throw new Exception("Invalid spawn.mpq size. Try clearing the cache and refreshing the page.");
        }
    }

    [JSInvokable]
    public void SetSaveName(int id) =>
        saveName = (id >= 0) ? (gameType == GameType.Shareware) ? $"spawn{id}.sv" : $"single_{id}.sv" : null;

    [JSInvokable]
    public async Task OnExit()
    {
        if (!AppState.Error)
        {
            timer.Dispose();
            timer = null;

            await Interop.Reload();
        }
    }

    [JSInvokable]
    public void OnProgress(Progress progress)
    {
        AppState.Progress = progress;

        StateHasChanged();
    }

    private double ProgressBarWidth =>
        AppState.Progress.Total != 0 ? Round(100d * AppState.Progress.Loaded / AppState.Progress.Total) : 100d;
}
